use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use worker::*;

use crate::tutor::UserContext;
use crate::AnalysisData;

/// Individual bullet in the ACE playbook
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct PlaybookBullet {
    pub id: String,
    pub content: String,
    pub helpful_count: u32,
    pub harmful_count: u32,
    pub last_used: DateTime<Utc>,
    pub confidence: f32,
    pub section: String, // "strategies", "failure_modes", "patterns", "techniques"
    pub tags: Vec<String>,
}

/// Delta operation for updating playbook
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum Operation {
    Add,
    Update,
    Remove,
}

/// Context delta for incremental updates
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ContextDelta {
    pub operation: Operation,
    pub bullet_id: Option<String>,
    pub content: String,
    pub section: String,
    pub tags: Vec<String>,
    pub confidence: f32,
    pub reasoning: String, // Why this delta was generated
}

/// The evolving piano pedagogy playbook
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PianoPlaybook {
    pub bullets: HashMap<String, PlaybookBullet>,
    pub last_updated: DateTime<Utc>,
    pub version: u32,
    pub total_feedback_count: u32,
}

impl PianoPlaybook {
    pub fn new() -> Self {
        Self {
            bullets: HashMap::new(),
            last_updated: Utc::now(),
            version: 1,
            total_feedback_count: 0,
        }
    }

    pub fn add_bullet(&mut self, delta: ContextDelta) -> String {
        let bullet_id = uuid::Uuid::new_v4().to_string();
        let bullet = PlaybookBullet {
            id: bullet_id.clone(),
            content: delta.content,
            helpful_count: 0,
            harmful_count: 0,
            last_used: Utc::now(),
            confidence: delta.confidence,
            section: delta.section,
            tags: delta.tags,
        };
        self.bullets.insert(bullet_id.clone(), bullet);
        self.last_updated = Utc::now();
        self.version += 1;
        bullet_id
    }

    pub fn update_bullet(
        &mut self,
        bullet_id: &str,
        delta: ContextDelta,
    ) -> std::result::Result<(), String> {
        if let Some(bullet) = self.bullets.get_mut(bullet_id) {
            bullet.content = delta.content;
            bullet.confidence = delta.confidence;
            bullet.tags = delta.tags;
            bullet.last_used = Utc::now();
            self.last_updated = Utc::now();
            self.version += 1;
            Ok(())
        } else {
            Err(format!("Bullet ID {} not found", bullet_id))
        }
    }

    pub fn remove_bullet(&mut self, bullet_id: &str) -> bool {
        if self.bullets.remove(bullet_id).is_some() {
            self.last_updated = Utc::now();
            self.version += 1;
            true
        } else {
            false
        }
    }

    pub fn get_bullets_by_section(&self, section: &str) -> Vec<&PlaybookBullet> {
        self.bullets
            .values()
            .filter(|b| b.section == section)
            .collect()
    }

    pub fn should_refine(&self) -> bool {
        // Refine if we have too many bullets or low-confidence entries
        self.bullets.len() > 100 || self.bullets.values().any(|b| b.confidence < 0.3)
    }

    pub async fn deduplicate_and_prune(&mut self) {
        // Remove low-confidence bullets
        let low_confidence_ids: Vec<String> = self
            .bullets
            .iter()
            .filter(|(_, bullet)| bullet.confidence < 0.3)
            .map(|(id, _)| id.clone())
            .collect();

        for id in low_confidence_ids {
            self.bullets.remove(&id);
        }

        // TODO: Implement semantic deduplication using embeddings
        self.last_updated = Utc::now();
        self.version += 1;
    }

    pub fn get_relevant_bullets(
        &self,
        tags: &[String],
        section: Option<&str>,
    ) -> Vec<&PlaybookBullet> {
        self.bullets
            .values()
            .filter(|bullet| {
                // Filter by section if specified
                if let Some(sec) = section {
                    if bullet.section != sec {
                        return false;
                    }
                }
                // Check for tag overlap
                tags.iter().any(|tag| bullet.tags.contains(tag)) || bullet.confidence > 0.7
                // High confidence bullets are always relevant
            })
            .collect()
    }
}

/// Initial feedback generated by the Generator agent
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct InitialFeedback {
    pub recommendations: Vec<String>,
    pub technique_focus: Vec<String>,
    pub practice_suggestions: Vec<String>,
    pub expected_timeline: String,
    pub citations: Vec<String>,
    pub reasoning_trace: String, // How the Generator arrived at these recommendations
}

/// Reflection and insights from the Reflector agent
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FeedbackReflection {
    pub quality_assessment: QualityAssessment,
    pub extracted_insights: Vec<String>,
    pub improvement_suggestions: Vec<String>,
    pub confidence_score: f32,
    pub deltas: Vec<ContextDelta>,
}

/// Quality assessment metrics
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct QualityAssessment {
    pub actionability_score: f32,     // How specific and actionable
    pub citation_accuracy_score: f32, // Do citations support claims
    pub user_alignment_score: f32,    // Appropriate for user context
    pub completeness_score: f32,      // Covers important aspects
    pub overall_score: f32,
}

/// Performance scores and context for feedback generation
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FeedbackContext {
    pub performance_scores: AnalysisData,
    pub user_context: UserContext,
    pub previous_sessions: Vec<String>, // Previous feedback IDs for learning
    pub session_id: String,
}

/// ACE system configuration
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct AceConfig {
    pub generator_model: String,
    pub reflector_model: String,
    pub curator_enabled: bool,
    pub max_playbook_size: usize,
    pub confidence_threshold: f32,
    pub cache_ttl_hours: u32,
}

impl Default for AceConfig {
    fn default() -> Self {
        Self {
            generator_model: "@cf/google/gemma-7b-it".to_string(),
            reflector_model: "@cf/google/gemma-7b-it".to_string(),
            curator_enabled: true,
            max_playbook_size: 500,
            confidence_threshold: 0.6,
            cache_ttl_hours: 24,
        }
    }
}

/// Trait for ACE agents
#[async_trait::async_trait(?Send)]
pub trait AceAgent {
    type Input;
    type Output;

    async fn process(&self, env: &Env, input: Self::Input) -> Result<Self::Output>;
    fn agent_name(&self) -> &'static str;
}

/// Error types for ACE operations
#[derive(Debug)]
pub enum AceError {
    LlmError(String),
    ParseError(String),
    StorageError(String),
    ValidationError(String),
}

impl std::fmt::Display for AceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AceError::LlmError(msg) => write!(f, "LLM Error: {}", msg),
            AceError::ParseError(msg) => write!(f, "Parse Error: {}", msg),
            AceError::StorageError(msg) => write!(f, "Storage Error: {}", msg),
            AceError::ValidationError(msg) => write!(f, "Validation Error: {}", msg),
        }
    }
}

impl From<AceError> for worker::Error {
    fn from(error: AceError) -> Self {
        worker::Error::RustError(error.to_string())
    }
}

/// Helper function to extract weakest performance dimensions
pub fn extract_weakest_dimensions(analysis: &AnalysisData, n: usize) -> Vec<(String, f32)> {
    let mut dimensions = vec![
        ("timing_stability", analysis.timing_stable_unstable),
        ("articulation_length", analysis.articulation_short_long),
        ("articulation_hardness", analysis.articulation_soft_hard),
        ("pedal_density", analysis.pedal_sparse_saturated),
        ("pedal_clarity", analysis.pedal_clean_blurred),
        ("timbre_color_variety", analysis.timbre_even_colorful),
        ("timbre_richness", analysis.timbre_shallow_rich),
        ("timbre_brightness", analysis.timbre_bright_dark),
        ("dynamic_range", analysis.timbre_soft_loud),
        ("dynamic_control", analysis.dynamic_sophisticated_raw),
        ("balance_melody_accomp", analysis.dynamic_range_little_large),
        ("tempo_control", analysis.music_making_fast_slow),
        ("phrasing_continuity", analysis.music_making_flat_spacious),
        (
            "expressiveness_intensity",
            analysis.music_making_disproportioned_balanced,
        ),
        ("energy_level", analysis.music_making_pure_dramatic),
        ("mood_character", analysis.emotion_mood_optimistic_dark),
        ("emotional_energy", analysis.emotion_mood_low_high_energy),
        (
            "interpretive_imagination",
            analysis.emotion_mood_honest_imaginative,
        ),
        (
            "overall_convincingness",
            analysis.interpretation_unsatisfactory_convincing,
        ),
    ];

    // Sort by score (lower is weaker)
    dimensions.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap_or(std::cmp::Ordering::Equal));

    dimensions
        .into_iter()
        .take(n)
        .map(|(name, score)| (name.to_string(), score))
        .collect()
}

/// Helper function to generate tags from performance scores and user context
pub fn generate_context_tags(analysis: &AnalysisData, user_context: &UserContext) -> Vec<String> {
    let mut tags = Vec::new();

    // Add weakness-based tags
    let weakest = extract_weakest_dimensions(analysis, 3);
    for (dimension, _) in weakest {
        tags.push(dimension);
    }

    // Add user context tags
    if user_context.practice_time_per_day_minutes < 30 {
        tags.push("limited_time".to_string());
    } else if user_context.practice_time_per_day_minutes > 120 {
        tags.push("extensive_practice".to_string());
    }

    // Add repertoire tags
    if let Some(rep) = &user_context.repertoire_info {
        if !rep.composer.is_empty() {
            tags.push(format!("composer_{}", rep.composer.to_lowercase()));
        }
        if let Some(difficulty) = rep.difficulty {
            if difficulty <= 3 {
                tags.push("beginner".to_string());
            } else if difficulty <= 6 {
                tags.push("intermediate".to_string());
            } else {
                tags.push("advanced".to_string());
            }
        }
    }

    tags
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_playbook_creation() {
        let playbook = PianoPlaybook::new();
        assert_eq!(playbook.bullets.len(), 0);
        assert_eq!(playbook.version, 1);
    }

    #[test]
    fn test_add_bullet() {
        let mut playbook = PianoPlaybook::new();
        let delta = ContextDelta {
            operation: Operation::Add,
            bullet_id: None,
            content: "Practice scales with metronome".to_string(),
            section: "techniques".to_string(),
            tags: vec!["timing_stability".to_string()],
            confidence: 0.8,
            reasoning: "User shows timing instability".to_string(),
        };

        let bullet_id = playbook.add_bullet(delta);
        assert_eq!(playbook.bullets.len(), 1);
        assert_eq!(playbook.version, 2);
        assert!(playbook.bullets.contains_key(&bullet_id));
    }

    #[test]
    fn test_extract_weakest_dimensions() {
        let analysis = AnalysisData {
            timing_stable_unstable: 0.2,
            articulation_short_long: 0.8,
            articulation_soft_hard: 0.6,
            pedal_sparse_saturated: 0.9,
            pedal_clean_blurred: 0.3,
            // Fill in other fields with default values
            timbre_even_colorful: 0.5,
            timbre_shallow_rich: 0.5,
            timbre_bright_dark: 0.5,
            timbre_soft_loud: 0.5,
            dynamic_sophisticated_raw: 0.5,
            dynamic_range_little_large: 0.5,
            music_making_fast_slow: 0.5,
            music_making_flat_spacious: 0.5,
            music_making_disproportioned_balanced: 0.5,
            music_making_pure_dramatic: 0.5,
            emotion_mood_optimistic_dark: 0.5,
            emotion_mood_low_high_energy: 0.5,
            emotion_mood_honest_imaginative: 0.5,
            interpretation_unsatisfactory_convincing: 0.5,
        };

        let weakest = extract_weakest_dimensions(&analysis, 3);
        assert_eq!(weakest.len(), 3);
        assert_eq!(weakest[0].0, "timing_stability");
        assert_eq!(weakest[0].1, 0.2);
    }

    #[test]
    fn test_generate_context_tags() {
        let analysis = AnalysisData {
            timing_stable_unstable: 0.2,
            // Fill other fields with defaults
            articulation_short_long: 0.5,
            articulation_soft_hard: 0.5,
            pedal_sparse_saturated: 0.5,
            pedal_clean_blurred: 0.5,
            timbre_even_colorful: 0.5,
            timbre_shallow_rich: 0.5,
            timbre_bright_dark: 0.5,
            timbre_soft_loud: 0.5,
            dynamic_sophisticated_raw: 0.5,
            dynamic_range_little_large: 0.5,
            music_making_fast_slow: 0.5,
            music_making_flat_spacious: 0.5,
            music_making_disproportioned_balanced: 0.5,
            music_making_pure_dramatic: 0.5,
            emotion_mood_optimistic_dark: 0.5,
            emotion_mood_low_high_energy: 0.5,
            emotion_mood_honest_imaginative: 0.5,
            interpretation_unsatisfactory_convincing: 0.5,
        };

        let user_context = UserContext {
            goals: vec!["Improve timing".to_string()],
            practice_time_per_day_minutes: 20,
            constraints: vec![],
            repertoire_info: Some(crate::tutor::RepertoireInfo {
                composer: "Bach".to_string(),
                piece: "Invention No. 1".to_string(),
                difficulty: Some(4),
            }),
        };

        let tags = generate_context_tags(&analysis, &user_context);
        assert!(tags.contains(&"timing_stability".to_string()));
        assert!(tags.contains(&"limited_time".to_string()));
        assert!(tags.contains(&"composer_bach".to_string()));
        assert!(tags.contains(&"intermediate".to_string()));
    }
}
